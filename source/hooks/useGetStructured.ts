// import { useState, useEffect } from 'react'
import { parse, NodeType, HTMLElement, TextNode, Node } from "node-html-parser";

enum NodeTagNames {
  PRE = "PRE",
  H2 = "H2",
}

export enum TagNames {
  B = "B",
  I = "I",
  RAW = "RAW", // No element, e.g. raw text
  NEWLINE = "NEWLINE",
}

type TextData = {
  type: TagNames;
  text: string;
}

const parsePre = (pre: HTMLElement) => {
  const root = parse(pre.rawText)
  const out: Array<TextData> = []
  for (let i = 0; i < root.childNodes.length; i++) {
    const child = root.childNodes[i]!
    // W don't care about comments
    // A child can only be one of three underlying types
    if (child.nodeType === NodeType.COMMENT_NODE) {
      continue;
    }
    // This inference is based on the underlying library
    // And the Node type in node-html-parser
    const childNode = child as HTMLElement | TextNode;
    const childIsHtmlElement = isHTMLElement(childNode);
    if (childIsHtmlElement) {
      // There are only ever B or I tags AFAIK
      if (childNode.tagName === TagNames.B) {
        out.push({
          type: TagNames.B,
          text: childNode.text
        })
      }
      if (childNode.tagName === TagNames.I) {
        out.push({
          type: TagNames.I,
          text: childNode.text
        })
      }
    } else {
      // We want to split on newlines, which we find in the raw text
      const trimmed = childNode.text
      const split = trimmed.split('\n\n')
      for (let i = 0; i < split.length; i++) {
        if (i !== 0) {
          out.push({
            type: TagNames.NEWLINE,
            text: ''
          })
        }
        if (split[i]) {
          out.push({
            type: TagNames.RAW,
            // Turn multiple spaces into one space
            text: split[i]!.replace(/\s\s+/g, ' '),
          })
        }
      }
    }
  }
  return out
}

export interface StructuredMan {
  // Standard headings https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap13.html
  name: string;
  data: Array<TextData>;
}

const isHTMLElement = (node: Node): node is HTMLElement => node.nodeType === NodeType.ELEMENT_NODE

/**
 * This is based on the output of man2html --bare
 * Principally, that a h2 element is followed by a pre element
 * The first element is an autogenerated element we wish to ignore
 */
const useGetStructured = (html: string) => {
  const root = parse(html);
  const children = root.childNodes;
  const structuredMan: StructuredMan[] = [];

  for (let i = 0; i < children.length; i++) {
    const child = children[i]!;
    // Ignore comment nodes
    if (child.nodeType === NodeType.COMMENT_NODE) {
      continue;
    }

    const childNode = child as HTMLElement | TextNode;
    const childIsHtmlElement = isHTMLElement(childNode);

    if (childIsHtmlElement) {
      // Ignore first comment, it is autogenerated
      // And has no header (previous h2 tag)
      if (i === 0) continue;
      const isPreTag = childNode.tagName === NodeTagNames.PRE;
      if (isPreTag) {
        const previous = children[i - 1] as HTMLElement;
        const prevIsH2Tag = previous.tagName === NodeTagNames.H2;
        if (prevIsH2Tag) {
          const item: StructuredMan = {
            name: previous.text,
            data: parsePre(childNode),
          };
          structuredMan.push(item);
        }
      }
    }
  }

  return structuredMan;
};

export default useGetStructured;
